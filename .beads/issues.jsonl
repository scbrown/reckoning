{"id":"reckoning-0yo","title":"F2: TTS Integration","description":"Connect game events to existing TTS system for narrator voice.\n\nIntegration work:\n- Map EventType to appropriate TTS voice role\n- Queue narration after DM submits content\n- Emit SSE events for TTS status (started/complete)\n- Update status bar with TTS state\n\nVoice role mapping:\n- narration ‚Üí narrator voice\n- party_dialogue ‚Üí character voice\n- npc_dialogue ‚Üí NPC voice\n- environment ‚Üí narrator voice","acceptance_criteria":"- [ ] Submitted narration events play via TTS\n- [ ] Correct voice roles used per EventType\n- [ ] TTS status shown in UI status bar\n- [ ] SSE events emitted for TTS lifecycle","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-10T22:29:53.806054407Z","created_by":"stiwi","updated_at":"2026-01-10T22:29:53.806054407Z","labels":["integration","phase-2","tts"],"dependencies":[{"issue_id":"reckoning-0yo","depends_on_id":"reckoning-42l","type":"blocks","created_at":"2026-01-10T22:29:53.807125042Z","created_by":"unknown"}]}
{"id":"reckoning-19b","title":"Phase 1: Text-to-Speech Engine","description":"Implement TTS system using ElevenLabs to provide voice narration for the game. Powers Chronicle narration, character dialogue, and Trial sequences.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T18:26:53.610959308Z","created_by":"admin","updated_at":"2026-01-10T19:15:55.370531194Z","closed_at":"2026-01-10T19:15:55.370531194Z","close_reason":"Phase 1 TTS Engine complete - all 7 child tasks delivered","labels":["epic","phase-1","tts"]}
{"id":"reckoning-19b.1","title":"Backend Proxy Service","description":"dispatched_by: mayor\n\nCreate Fastify backend server with /api/tts/speak endpoint (streaming response), API key management, request validation, CORS setup, and health check endpoint.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T18:27:10.317378119Z","created_by":"admin","updated_at":"2026-01-10T18:45:40.495750779Z","closed_at":"2026-01-10T18:45:40.495750779Z","close_reason":"Implemented by polecat furiosa - TTS proxy endpoints with Zod validation, CORS, API key management","labels":["backend","phase-1","tts"],"dependencies":[{"issue_id":"reckoning-19b.1","depends_on_id":"reckoning-19b","type":"parent-child","created_at":"2026-01-10T18:27:10.317970621Z","created_by":"admin"},{"issue_id":"reckoning-19b.1","depends_on_id":"reckoning-19b.7","type":"blocks","created_at":"2026-01-10T18:27:52.900851293Z","created_by":"admin"}]}
{"id":"reckoning-19b.2","title":"ElevenLabs API Integration","description":"dispatched_by: mayor\n\nCreate ElevenLabs API client wrapper with textToSpeech() method, getVoices() for voice discovery, streaming response handling for long text, error handling/retries, and TypeScript types for API responses.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T18:27:11.034591309Z","created_by":"admin","updated_at":"2026-01-10T18:44:38.819401047Z","closed_at":"2026-01-10T18:44:38.819401047Z","close_reason":"Implemented ElevenLabs API client with textToSpeech() streaming, getVoices(), exponential backoff retries, and full TypeScript types","labels":["backend","elevenlabs","phase-1","tts"],"dependencies":[{"issue_id":"reckoning-19b.2","depends_on_id":"reckoning-19b","type":"parent-child","created_at":"2026-01-10T18:27:11.041012432Z","created_by":"admin"},{"issue_id":"reckoning-19b.2","depends_on_id":"reckoning-19b.7","type":"blocks","created_at":"2026-01-10T18:27:53.539235408Z","created_by":"admin"}]}
{"id":"reckoning-19b.3","title":"Redis Caching Layer","description":"dispatched_by: mayor\n\nImplement caching layer for TTS: cache key strategy (hash of text + voice + settings), Redis connection with ioredis, cache-aside pattern, buffer streamed response for storage while forwarding to client, TTL policies (7 days narration, 30 days static dialogue), cache hit/miss logging.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-10T18:27:12.991033833Z","created_by":"admin","updated_at":"2026-01-10T18:52:58.03883084Z","closed_at":"2026-01-10T18:52:58.03883084Z","close_reason":"Implemented by polecat nux - Redis caching with cache-aside pattern, TTL policies, hit/miss logging","labels":["backend","cache","phase-1","redis","tts"],"dependencies":[{"issue_id":"reckoning-19b.3","depends_on_id":"reckoning-19b","type":"parent-child","created_at":"2026-01-10T18:27:12.991694476Z","created_by":"admin"},{"issue_id":"reckoning-19b.3","depends_on_id":"reckoning-19b.2","type":"blocks","created_at":"2026-01-10T18:27:54.377981396Z","created_by":"admin"}]}
{"id":"reckoning-19b.4","title":"Client-Side TTS Service","description":"dispatched_by: mayor\n\nCreate TTSService class for browser: audio queue for sequential playback, playback controls (pause, resume, skip, stop), Web Audio API handling, volume control, preloading for anticipated speech.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T18:27:13.587848293Z","created_by":"admin","updated_at":"2026-01-10T18:52:57.937482732Z","closed_at":"2026-01-10T18:52:57.937482732Z","close_reason":"Implemented by polecat furiosa - Client-side TTS service with audio queue, playback controls, volume, preloading","labels":["audio","client","phase-1","tts"],"dependencies":[{"issue_id":"reckoning-19b.4","depends_on_id":"reckoning-19b","type":"parent-child","created_at":"2026-01-10T18:27:13.588466959Z","created_by":"admin"},{"issue_id":"reckoning-19b.4","depends_on_id":"reckoning-19b.1","type":"blocks","created_at":"2026-01-10T18:27:55.510628051Z","created_by":"admin"}]}
{"id":"reckoning-19b.5","title":"Voice Configuration System","description":"dispatched_by: mayor\n\nCreate voice registry with role mappings (narrator, judge, npc, inner_voice), implement voice preset system for different contexts (chronicle, dialogue_calm, dialogue_intense, trial_judgment), runtime voice switching, voice selection UI for testing.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-10T18:27:14.244133087Z","created_by":"admin","updated_at":"2026-01-10T19:15:49.839682774Z","closed_at":"2026-01-10T19:15:49.839682774Z","close_reason":"Phase 1 TTS complete - voice config and tests/docs delivered","labels":["config","phase-1","tts"],"dependencies":[{"issue_id":"reckoning-19b.5","depends_on_id":"reckoning-19b","type":"parent-child","created_at":"2026-01-10T18:27:14.251074747Z","created_by":"admin"},{"issue_id":"reckoning-19b.5","depends_on_id":"reckoning-19b.7","type":"blocks","created_at":"2026-01-10T18:27:56.456224457Z","created_by":"admin"}]}
{"id":"reckoning-19b.6","title":"TTS Testing \u0026 Documentation","description":"dispatched_by: mayor\n\nUnit tests for TTS service, integration tests with mocked ElevenLabs, E2E test for full speech flow, API documentation, usage examples. Target: \u003e80% coverage on TTS service.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-10T18:27:14.369765727Z","created_by":"admin","updated_at":"2026-01-10T19:15:49.849533002Z","closed_at":"2026-01-10T19:15:49.849533002Z","close_reason":"Phase 1 TTS complete - voice config and tests/docs delivered","labels":["docs","phase-1","testing","tts"],"dependencies":[{"issue_id":"reckoning-19b.6","depends_on_id":"reckoning-19b","type":"parent-child","created_at":"2026-01-10T18:27:14.370519348Z","created_by":"admin"}]}
{"id":"reckoning-19b.7","title":"Shared TTS Types","description":"dispatched_by: mayor\n\nDefine shared TypeScript types in @reckoning/shared: TTSRequest, SpeakOptions, VoiceRole, VoicePreset, ITTSService interface. These types will be used by both client and server.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T18:27:21.447185058Z","created_by":"admin","updated_at":"2026-01-10T18:39:35.578975854Z","closed_at":"2026-01-10T18:39:35.578975854Z","close_reason":"Implemented by polecat furiosa - SpeakOptions and ITTSService types added to @reckoning/shared","labels":["phase-1","shared","tts","types"],"dependencies":[{"issue_id":"reckoning-19b.7","depends_on_id":"reckoning-19b","type":"parent-child","created_at":"2026-01-10T18:27:21.447800343Z","created_by":"admin"}]}
{"id":"reckoning-1zj","title":"E4: UI Components - Core","description":"Create core UI components for DM interaction.\n\n## Files to Create\n\n```\npackages/client/src/components/\n‚îú‚îÄ‚îÄ dm-editor.ts          # Main content editor\n‚îú‚îÄ‚îÄ narrator-output.ts    # Scrolling narrative history\n‚îú‚îÄ‚îÄ controls.ts           # Accept/Edit/Regenerate/Inject buttons\n‚îî‚îÄ‚îÄ playback-controls.ts  # Auto/Pause/Step/Stop controls\n```\n\n## Component Pattern\n\nAll components follow this pattern:\n\n```typescript\ninterface ComponentConfig {\n  containerId: string;\n  // component-specific options\n}\n\nclass Component {\n  protected container: HTMLElement;\n  protected state: GameStateManager;\n  \n  constructor(config: ComponentConfig, state: GameStateManager);\n  \n  // Render component\n  render(): void;\n  \n  // Update from state\n  update(state: ClientGameState): void;\n  \n  // Cleanup\n  destroy(): void;\n}\n```\n\n## DMEditor\n\nThe main editor for reviewing and editing AI-generated content.\n\n```typescript\nclass DMEditor {\n  private textarea: HTMLTextAreaElement;\n  private originalContent: string = '';\n  private isEditing: boolean = false;\n  \n  constructor(containerId: string, state: GameStateManager);\n  \n  render(): void;\n  \n  // Update with new pending content\n  update(state: ClientGameState): void;\n  \n  // Get current edited content\n  getContent(): string;\n  \n  // Check if content was modified\n  isModified(): boolean;\n  \n  // Enable/disable editing\n  setEnabled(enabled: boolean): void;\n  \n  // Show loading state\n  setLoading(loading: boolean): void;\n}\n```\n\n### DMEditor HTML Structure\n\n```html\n\u003cdiv class=\"dm-editor\"\u003e\n  \u003cdiv class=\"dm-editor-header\"\u003e\n    \u003cspan class=\"dm-editor-title\"\u003eDM Editor\u003c/span\u003e\n    \u003cspan class=\"dm-editor-status\"\u003eReviewing\u003c/span\u003e\n  \u003c/div\u003e\n  \u003cdiv class=\"dm-editor-content\"\u003e\n    \u003ctextarea class=\"dm-editor-textarea\" placeholder=\"AI will generate content here...\"\u003e\u003c/textarea\u003e\n    \u003cdiv class=\"dm-editor-loading\"\u003e\n      \u003cspan class=\"spinner\"\u003e\u003c/span\u003e\n      \u003cspan\u003eGenerating...\u003c/span\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n  \u003cdiv class=\"dm-editor-meta\"\u003e\n    \u003cspan class=\"event-type-badge\"\u003eparty_action\u003c/span\u003e\n    \u003cspan class=\"speaker\"\u003eMarcus\u003c/span\u003e\n  \u003c/div\u003e\n\u003c/div\u003e\n```\n\n## NarratorOutput\n\nScrolling narrative history display.\n\n```typescript\nclass NarratorOutput {\n  private entries: HTMLElement;\n  private autoScroll: boolean = true;\n  \n  constructor(containerId: string, state: GameStateManager);\n  \n  render(): void;\n  update(state: ClientGameState): void;\n  \n  // Add new narrative entry\n  addEntry(entry: NarrativeEntry): void;\n  \n  // Scroll to bottom\n  scrollToBottom(): void;\n  \n  // Toggle auto-scroll\n  setAutoScroll(enabled: boolean): void;\n  \n  // Clear all entries\n  clear(): void;\n}\n```\n\n### NarratorOutput HTML Structure\n\n```html\n\u003cdiv class=\"narrator-output\"\u003e\n  \u003cdiv class=\"narrator-header\"\u003e\n    \u003cspan\u003eNarrative\u003c/span\u003e\n    \u003clabel\u003e\u003cinput type=\"checkbox\" checked\u003e Auto-scroll\u003c/label\u003e\n  \u003c/div\u003e\n  \u003cdiv class=\"narrator-entries\"\u003e\n    \u003cdiv class=\"narrative-entry narration\"\u003e\n      \u003cspan class=\"entry-content\"\u003eThe tavern door creaks open...\u003c/span\u003e\n    \u003c/div\u003e\n    \u003cdiv class=\"narrative-entry party_dialogue\"\u003e\n      \u003cspan class=\"entry-speaker\"\u003eKira:\u003c/span\u003e\n      \u003cspan class=\"entry-content\"\u003e\"Did anyone else hear that?\"\u003c/span\u003e\n      \u003cspan class=\"tts-indicator playing\"\u003eüîä\u003c/span\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n\u003c/div\u003e\n```\n\n## Controls\n\nAction buttons for DM decisions.\n\n```typescript\ninterface ControlsCallbacks {\n  onAccept: () =\u003e void;\n  onEdit: () =\u003e void;\n  onRegenerate: () =\u003e void;\n  onInject: () =\u003e void;\n}\n\nclass Controls {\n  constructor(containerId: string, callbacks: ControlsCallbacks);\n  \n  render(): void;\n  \n  // Enable/disable specific buttons\n  setEnabled(button: 'accept' | 'edit' | 'regenerate' | 'inject', enabled: boolean): void;\n  \n  // Set all buttons enabled/disabled\n  setAllEnabled(enabled: boolean): void;\n  \n  // Show regenerate feedback input\n  showRegenerateFeedback(): void;\n}\n```\n\n### Controls HTML Structure\n\n```html\n\u003cdiv class=\"controls\"\u003e\n  \u003cbutton class=\"btn btn-accept\" title=\"Submit as-is\"\u003eAccept\u003c/button\u003e\n  \u003cbutton class=\"btn btn-edit\" title=\"Edit and submit\"\u003eEdit\u003c/button\u003e\n  \u003cbutton class=\"btn btn-regenerate\" title=\"Ask AI to try again\"\u003eRegenerate\u003c/button\u003e\n  \u003cbutton class=\"btn btn-inject\" title=\"Write your own\"\u003eInject\u003c/button\u003e\n\u003c/div\u003e\n\u003cdiv class=\"regenerate-feedback\" hidden\u003e\n  \u003cinput type=\"text\" placeholder=\"Feedback for AI (optional)...\"\u003e\n  \u003cbutton class=\"btn-small\"\u003eSubmit\u003c/button\u003e\n\u003c/div\u003e\n```\n\n## PlaybackControls\n\nPlayback mode controls.\n\n```typescript\nclass PlaybackControls {\n  private currentMode: PlaybackMode = 'auto';\n  \n  constructor(containerId: string, onModeChange: (mode: PlaybackMode) =\u003e void);\n  \n  render(): void;\n  \n  // Update displayed mode\n  setMode(mode: PlaybackMode): void;\n  \n  // Enable/disable controls\n  setEnabled(enabled: boolean): void;\n}\n```\n\n### PlaybackControls HTML Structure\n\n```html\n\u003cdiv class=\"playback-controls\"\u003e\n  \u003cbutton class=\"btn-playback active\" data-mode=\"auto\" title=\"Auto-advance\"\u003e‚ñ∂ Auto\u003c/button\u003e\n  \u003cbutton class=\"btn-playback\" data-mode=\"paused\" title=\"Pause\"\u003e‚è∏ Pause\u003c/button\u003e\n  \u003cbutton class=\"btn-playback\" data-mode=\"stepping\" title=\"Step\"\u003e‚è≠ Step\u003c/button\u003e\n  \u003cbutton class=\"btn-playback\" data-mode=\"stopped\" title=\"Stop\"\u003e‚èπ Stop\u003c/button\u003e\n\u003c/div\u003e\n```\n\n## Styling\n\nUse existing dark theme from Phase 1:\n- Background: #0a0a0a\n- Text: #e0e0e0\n- Accent: #667eea ‚Üí #764ba2 gradient\n- Borders: #333, #444","acceptance_criteria":"- [ ] DMEditor component created\n- [ ] DMEditor shows pending content in textarea\n- [ ] DMEditor tracks modified state\n- [ ] DMEditor shows loading spinner during generation\n- [ ] NarratorOutput component created\n- [ ] NarratorOutput displays narrative history\n- [ ] NarratorOutput auto-scrolls (toggleable)\n- [ ] NarratorOutput shows TTS playing indicator\n- [ ] Controls component with Accept/Edit/Regenerate/Inject\n- [ ] Controls can be individually enabled/disabled\n- [ ] Regenerate shows feedback input\n- [ ] PlaybackControls with Auto/Pause/Step/Stop\n- [ ] PlaybackControls highlights current mode\n- [ ] All components follow dark theme\n- [ ] All components update from state","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-10T22:28:00.631124499Z","created_by":"stiwi","updated_at":"2026-01-10T22:28:00.631124499Z","labels":["client","phase-2","ui"],"dependencies":[{"issue_id":"reckoning-1zj","depends_on_id":"reckoning-7el","type":"blocks","created_at":"2026-01-10T22:28:00.652063158Z","created_by":"unknown"}]}
{"id":"reckoning-2cv","title":"Add client TTS service tests","description":"The client package has no tests. Phase 1 acceptance criteria requires \u003e80% test coverage on TTS service.\n\nNeed to add unit tests for packages/client/src/services/tts/index.ts covering:\n- Queue management (speak, preload, clearQueue)\n- Playback controls (play, pause, resume, skip, stop)\n- Volume control\n- Event callbacks\n- Error handling\n- dispose() lifecycle","acceptance_criteria":"- [ ] Unit tests for TTSService class\n- [ ] Tests cover queue management\n- [ ] Tests cover playback controls\n- [ ] Tests cover error scenarios\n- [ ] Test coverage meets \u003e80% for TTS service","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T22:32:18.565826383Z","created_by":"stiwi","updated_at":"2026-01-10T23:04:49.704613411Z","closed_at":"2026-01-10T23:04:49.704613411Z","close_reason":"Implemented by polecat slit - client TTS service tests added","labels":["client","phase-1","testing","tts"]}
{"id":"reckoning-2vq","title":"C1: Claude CLI Wrapper","description":"Create Claude Code CLI wrapper using subprocess spawn pattern.\n\n## Files to Create\n\n```\npackages/server/src/services/ai/\n‚îú‚îÄ‚îÄ index.ts          # Exports\n‚îú‚îÄ‚îÄ types.ts          # AIProvider interface, error types\n‚îî‚îÄ‚îÄ claude-cli.ts     # ClaudeCodeCLI implementation\n```\n\n## types.ts\n\n```typescript\nimport { Result } from '@reckoning/shared';\n\ninterface AIRequest {\n  prompt: string;\n  systemPrompt?: string;\n  maxTokens?: number;\n}\n\ninterface AIResponse {\n  content: string;\n  durationMs: number;\n}\n\ninterface AIError {\n  code: 'TIMEOUT' | 'UNAVAILABLE' | 'EXECUTION_ERROR' | 'PARSE_ERROR';\n  message: string;\n  retryable: boolean;\n}\n\n// Abstract interface for swappable AI backends\ninterface AIProvider {\n  name: string;\n  execute(request: AIRequest): Promise\u003cResult\u003cAIResponse, AIError\u003e\u003e;\n  isAvailable(): Promise\u003cboolean\u003e;\n}\n```\n\n## claude-cli.ts\n\n```typescript\nimport { spawn } from 'child_process';\n\ninterface ClaudeCLIConfig {\n  timeout?: number;           // Default: 60000ms\n  maxOutputLength?: number;   // Default: 50000 chars\n  cliCommand?: string;        // Default: 'claude'\n}\n\nclass ClaudeCodeCLI implements AIProvider {\n  readonly name = 'claude-cli';\n  private config: Required\u003cClaudeCLIConfig\u003e;\n  \n  constructor(config?: ClaudeCLIConfig);\n  \n  // Execute prompt via CLI subprocess\n  async execute(request: AIRequest): Promise\u003cResult\u003cAIResponse, AIError\u003e\u003e;\n  \n  // Check if claude CLI is available\n  async isAvailable(): Promise\u003cboolean\u003e;\n  \n  // Internal: spawn subprocess and collect output\n  private async spawnClaude(prompt: string): Promise\u003c{ stdout: string; stderr: string; exitCode: number }\u003e;\n}\n```\n\n## Subprocess Implementation\n\n```typescript\nprivate async spawnClaude(prompt: string): Promise\u003c...\u003e {\n  return new Promise((resolve, reject) =\u003e {\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() =\u003e controller.abort(), this.config.timeout);\n    \n    // Spawn: claude -p \"prompt\"\n    const proc = spawn(this.config.cliCommand, ['-p', prompt], {\n      signal: controller.signal,\n      shell: true,\n      env: { ...process.env },\n    });\n    \n    let stdout = '';\n    let stderr = '';\n    \n    proc.stdout.on('data', (data) =\u003e {\n      stdout += data.toString();\n      // Truncate if too long\n      if (stdout.length \u003e this.config.maxOutputLength) {\n        proc.kill();\n      }\n    });\n    \n    proc.stderr.on('data', (data) =\u003e {\n      stderr += data.toString();\n    });\n    \n    proc.on('close', (code) =\u003e {\n      clearTimeout(timeoutId);\n      resolve({ stdout, stderr, exitCode: code ?? 0 });\n    });\n    \n    proc.on('error', (err) =\u003e {\n      clearTimeout(timeoutId);\n      reject(err);\n    });\n  });\n}\n```\n\n## isAvailable Check\n\n```typescript\nasync isAvailable(): Promise\u003cboolean\u003e {\n  try {\n    const { exitCode } = await this.spawnClaude('--version');\n    return exitCode === 0;\n  } catch {\n    return false;\n  }\n}\n```\n\n## Error Handling\n\n- TIMEOUT: AbortController triggers after config.timeout\n- UNAVAILABLE: CLI not found or failed to spawn\n- EXECUTION_ERROR: Non-zero exit code\n- PARSE_ERROR: Output couldn't be processed\n\n## Notes\n\n- Use Result type from @reckoning/shared for error handling\n- Log execution time for monitoring\n- Consider streaming output for long generations (future enhancement)","acceptance_criteria":"- [ ] ClaudeCodeCLI class implements AIProvider interface\n- [ ] execute() spawns claude CLI subprocess\n- [ ] Timeout works via AbortController (default 60s)\n- [ ] isAvailable() returns true when claude CLI exists\n- [ ] isAvailable() returns false when CLI not found\n- [ ] Errors return proper AIError with code and retryable flag\n- [ ] Output truncated if exceeds maxOutputLength\n- [ ] Unit tests with mocked child_process\n- [ ] Integration test with actual claude CLI (if available)\n- [ ] Execution time tracked in response","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T22:24:40.731460008Z","created_by":"stiwi","updated_at":"2026-01-10T23:06:55.267937216Z","closed_at":"2026-01-10T23:06:55.267937216Z","close_reason":"Implemented by polecat dementus - Claude CLI wrapper added","labels":["ai","claude","phase-2","server"],"dependencies":[{"issue_id":"reckoning-2vq","depends_on_id":"reckoning-8jy","type":"blocks","created_at":"2026-01-10T22:24:40.732862009Z","created_by":"unknown"}]}
{"id":"reckoning-3bw","title":"C2: Prompt Templates","description":"Create prompt templates for AI content generation.\n\n## Files to Create\n\n```\npackages/server/src/services/ai/prompts/\n‚îú‚îÄ‚îÄ index.ts          # buildPrompt() and exports\n‚îú‚îÄ‚îÄ system.ts         # System prompts establishing DM assistant role\n‚îú‚îÄ‚îÄ scene.ts          # Scene description prompts\n‚îú‚îÄ‚îÄ party.ts          # Party action/dialogue prompts\n‚îú‚îÄ‚îÄ npc.ts            # NPC response prompts\n‚îî‚îÄ‚îÄ environment.ts    # Environment event prompts\n```\n\n## system.ts - Base System Prompt\n\n```typescript\nexport const DM_SYSTEM_PROMPT = `You are an AI assistant helping a human Dungeon Master run \"The Reckoning\" RPG.\n\nYour role:\n- Generate narrative content for the DM to review and edit\n- Suggest party member actions and dialogue\n- Create NPC responses and environmental descriptions\n- Classify your output with the appropriate EventType\n\nThe DM has full editorial control - they may accept, edit, or reject your suggestions.\n\nOutput Format:\nAlways respond with valid JSON in this format:\n{\n  \"eventType\": \"party_action\" | \"party_dialogue\" | \"npc_action\" | \"npc_dialogue\" | \"narration\" | \"environment\",\n  \"content\": \"The narrative text...\",\n  \"speaker\": \"Character name if dialogue, null otherwise\",\n  \"suggestedActions\": [\"Optional array of follow-up options\"]\n}\n\nGuidelines:\n- Be descriptive and atmospheric\n- Stay consistent with established facts\n- Respect character personalities\n- Create opportunities for interesting choices\n- Never break the fourth wall`;\n```\n\n## scene.ts - Scene Description\n\n```typescript\nexport function buildScenePrompt(area: Area, context: { \n  npcs: NPC[]; \n  isFirstVisit: boolean;\n  timeOfDay?: string;\n}): string {\n  return `\nDescribe the scene for the party entering: ${area.name}\n\nLocation Details:\n${area.description}\n\nExits: ${area.exits.map(e =\u003e `${e.direction}: ${e.description}`).join(', ')}\nObjects: ${area.objects.map(o =\u003e o.name).join(', ')}\nNPCs Present: ${context.npcs.map(n =\u003e `${n.name} (${n.disposition})`).join(', ') || 'None'}\n\nFirst visit: ${context.isFirstVisit ? 'Yes' : 'No'}\n${context.timeOfDay ? `Time: ${context.timeOfDay}` : ''}\n\nGenerate an atmospheric description of this location. Use eventType: \"narration\".\n`;\n}\n```\n\n## party.ts - Party Action/Dialogue\n\n```typescript\nexport function buildPartyPrompt(context: {\n  party: Character[];\n  currentArea: Area;\n  recentEvents: CanonicalEvent[];\n  dmGuidance?: string;\n}): string {\n  return `\nGenerate the next party member action or dialogue.\n\nParty Members:\n${context.party.map(c =\u003e `- ${c.name}: ${c.description} (Class: ${c.class})`).join('\\n')}\n\nCurrent Location: ${context.currentArea.name}\n\nRecent Events:\n${formatRecentEvents(context.recentEvents)}\n\n${context.dmGuidance ? `DM Guidance: ${context.dmGuidance}` : ''}\n\nGenerate what a party member does or says next. Be specific about which character.\nUse eventType: \"party_action\" for actions, \"party_dialogue\" for speech.\n`;\n}\n```\n\n## npc.ts - NPC Response\n\n```typescript\nexport function buildNPCPrompt(context: {\n  npc: NPC;\n  triggeringEvent: CanonicalEvent;\n  currentArea: Area;\n  recentEvents: CanonicalEvent[];\n}): string {\n  return `\nGenerate ${context.npc.name}'s response to the party.\n\nNPC: ${context.npc.name}\nDescription: ${context.npc.description}\nDisposition: ${context.npc.disposition}\n\nTriggering Event:\n${context.triggeringEvent.content}\n\nLocation: ${context.currentArea.name}\n\nRecent Context:\n${formatRecentEvents(context.recentEvents)}\n\nGenerate the NPC's reaction - action, dialogue, or both.\nUse eventType: \"npc_action\" for actions, \"npc_dialogue\" for speech.\n`;\n}\n```\n\n## environment.ts - Environment Events\n\n```typescript\nexport function buildEnvironmentPrompt(context: {\n  currentArea: Area;\n  recentEvents: CanonicalEvent[];\n  trigger?: 'time_passage' | 'consequence' | 'random' | 'atmosphere';\n}): string {\n  return `\nGenerate an environmental event or atmospheric detail.\n\nLocation: ${context.currentArea.name}\n${context.currentArea.description}\n\nTags: ${context.currentArea.tags.join(', ')}\n\nTrigger: ${context.trigger || 'atmosphere'}\n\nRecent Events:\n${formatRecentEvents(context.recentEvents)}\n\nGenerate something happening in the environment - sounds, weather, ambient details, or consequences of recent actions.\nUse eventType: \"environment\".\n`;\n}\n```\n\n## index.ts - Prompt Builder\n\n```typescript\nimport { GenerationContext } from '@reckoning/shared';\n\nexport function buildPrompt(context: GenerationContext): string {\n  const systemPrompt = DM_SYSTEM_PROMPT;\n  \n  let userPrompt: string;\n  switch (context.type) {\n    case 'scene_description':\n      userPrompt = buildScenePrompt(...);\n      break;\n    case 'party_action':\n      userPrompt = buildPartyPrompt(...);\n      break;\n    case 'npc_response':\n      userPrompt = buildNPCPrompt(...);\n      break;\n    case 'environment_event':\n      userPrompt = buildEnvironmentPrompt(...);\n      break;\n  }\n  \n  return `${systemPrompt}\\n\\n---\\n\\n${userPrompt}`;\n}\n\n// Helper to format recent events for context\nfunction formatRecentEvents(events: CanonicalEvent[], limit = 10): string;\n```","acceptance_criteria":"- [ ] All prompt template files created\n- [ ] DM_SYSTEM_PROMPT establishes AI assistant role\n- [ ] buildScenePrompt generates scene descriptions\n- [ ] buildPartyPrompt generates party actions/dialogue\n- [ ] buildNPCPrompt generates NPC responses\n- [ ] buildEnvironmentPrompt generates environment events\n- [ ] buildPrompt() routes to correct template based on context.type\n- [ ] Output format instructions request JSON with eventType\n- [ ] formatRecentEvents helper limits and formats history\n- [ ] Unit tests verify prompt structure\n- [ ] Manual test: prompts produce expected AI output format","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-10T22:25:08.92012216Z","created_by":"stiwi","updated_at":"2026-01-10T22:25:08.92012216Z","labels":["ai","phase-2","prompts","server"],"dependencies":[{"issue_id":"reckoning-3bw","depends_on_id":"reckoning-2vq","type":"blocks","created_at":"2026-01-10T22:25:08.921348516Z","created_by":"unknown"}]}
{"id":"reckoning-42l","title":"F1: End-to-End Integration","description":"Wire server and client together for full game loop testing.\n\nIntegration work:\n- Verify SSE events flow from server to client\n- Test full game cycle: generate ‚Üí review ‚Üí edit ‚Üí submit\n- Test save/load functionality end-to-end\n- Test playback controls (auto/pause/step/stop)\n- Verify event persistence across sessions\n\nThis task validates the complete system works together.","acceptance_criteria":"- [ ] Can start new game (AI generates initial content)\n- [ ] AI-generated content appears in DM editor\n- [ ] DM can edit and submit content\n- [ ] Events persist to SQLite and survive restart\n- [ ] SSE events update client in real-time\n- [ ] Save/load works correctly\n- [ ] Playback controls function as expected","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-10T22:29:46.996807395Z","created_by":"stiwi","updated_at":"2026-01-10T22:29:46.996807395Z","labels":["integration","phase-2","testing"],"dependencies":[{"issue_id":"reckoning-42l","depends_on_id":"reckoning-9ia","type":"blocks","created_at":"2026-01-10T22:29:46.997965818Z","created_by":"unknown"},{"issue_id":"reckoning-42l","depends_on_id":"reckoning-abi","type":"blocks","created_at":"2026-01-10T22:29:46.999106475Z","created_by":"unknown"}]}
{"id":"reckoning-4ot","title":"Fix failing TTS route tests","description":"27 server TTS tests are failing due to ioredis mock issue.\n\nThe mock at packages/server/src/routes/__tests__/tts.test.ts:46-47 tries to access Redis.mock.results which is undefined with current vitest mock setup.\n\nError: TypeError: Cannot read properties of undefined (reading 'value')\n\nNeed to fix the mock setup to properly capture the mock Redis instance.","acceptance_criteria":"- [ ] All 27 TTS route tests pass\n- [ ] Mock properly captures Redis instance\n- [ ] No regression in other tests","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-10T22:32:18.487273733Z","created_by":"stiwi","updated_at":"2026-01-10T23:32:19.671501896Z","closed_at":"2026-01-10T23:32:19.671501896Z","close_reason":"Fixed TTS route tests and TypeScript errors. Rewrote tests to match actual implementation. Fixed duplicate SSE type exports in shared package.","labels":["bug","phase-1","testing","tts"],"comments":[{"id":1,"issue_id":"reckoning-4ot","author":"stiwi","text":"Fix was never merged - tests still failing","created_at":"2026-01-10T23:20:09Z"}]}
{"id":"reckoning-7el","title":"E3: Client State Management","description":"Create client-side state management synced with SSE events.\n\n## Files to Create\n\n```\npackages/client/src/state/\n‚îú‚îÄ‚îÄ index.ts          # Exports\n‚îú‚îÄ‚îÄ game-state.ts     # GameStateManager class\n‚îî‚îÄ‚îÄ types.ts          # State types\n```\n\n## State Shape\n\n```typescript\ninterface ClientGameState {\n  // Connection\n  connected: boolean;\n  gameId: string | null;\n  \n  // Game data\n  session: GameSession | null;\n  editorState: DMEditorState | null;\n  pendingContent: GeneratedContent | null;\n  \n  // System status\n  systemStatus: SystemStatus | null;\n  observation: GameObservation | null;\n  \n  // UI state\n  isLoading: boolean;\n  error: string | null;\n  \n  // Narrative history (for display)\n  narrativeHistory: NarrativeEntry[];\n}\n\ninterface NarrativeEntry {\n  id: string;\n  type: EventType;\n  content: string;\n  speaker?: string;\n  timestamp: Date;\n  isTTSPlaying?: boolean;\n}\n```\n\n## GameStateManager\n\n```typescript\ntype StateListener = (state: ClientGameState) =\u003e void;\n\nclass GameStateManager {\n  private state: ClientGameState;\n  private listeners: Set\u003cStateListener\u003e = new Set();\n  private sseService: SSEService;\n  private gameService: GameService;\n  \n  constructor(sseService: SSEService, gameService: GameService);\n  \n  // Get current state (immutable)\n  getState(): Readonly\u003cClientGameState\u003e;\n  \n  // Subscribe to state changes\n  subscribe(listener: StateListener): () =\u003e void;\n  \n  // Initialize with a game\n  async initGame(gameId: string): Promise\u003cvoid\u003e;\n  \n  // Start new game\n  async startNewGame(playerName: string, description?: string): Promise\u003cvoid\u003e;\n  \n  // Load saved game\n  async loadSavedGame(slotId: string): Promise\u003cvoid\u003e;\n  \n  // Clear current game\n  clearGame(): void;\n  \n  // Actions (delegate to GameService, update state)\n  async submitContent(action: DMAction): Promise\u003cvoid\u003e;\n  async regenerateContent(feedback?: string): Promise\u003cvoid\u003e;\n  async injectContent(content: string, eventType: EventType): Promise\u003cvoid\u003e;\n  async triggerNext(options?: { type?: string; dmGuidance?: string }): Promise\u003cvoid\u003e;\n  async setPlaybackMode(mode: PlaybackMode): Promise\u003cvoid\u003e;\n  async saveGame(name: string): Promise\u003cvoid\u003e;\n  \n  // Update editor (local + server sync)\n  async updateEditorContent(content: string): Promise\u003cvoid\u003e;\n}\n```\n\n## SSE Event Handling\n\n```typescript\nprivate setupSSEHandlers(): void {\n  this.sseService.on('state_changed', (event) =\u003e {\n    this.updateState({ session: { ...this.state.session, state: event.state } });\n  });\n  \n  this.sseService.on('generation_started', (event) =\u003e {\n    this.updateState({ \n      isLoading: true,\n      systemStatus: {\n        ...this.state.systemStatus,\n        ai: { status: 'generating' }\n      }\n    });\n  });\n  \n  this.sseService.on('generation_complete', (event) =\u003e {\n    this.updateState({\n      isLoading: false,\n      pendingContent: event.content,\n      editorState: {\n        pending: event.content,\n        editedContent: event.content.content,\n        status: 'reviewing'\n      },\n      systemStatus: {\n        ...this.state.systemStatus,\n        ai: { status: 'idle', lastGenerationMs: event.durationMs }\n      }\n    });\n  });\n  \n  this.sseService.on('generation_error', (event) =\u003e {\n    this.updateState({\n      isLoading: false,\n      error: event.error,\n      systemStatus: {\n        ...this.state.systemStatus,\n        ai: { status: 'error', errorMessage: event.error }\n      }\n    });\n  });\n  \n  this.sseService.on('editor_state', (event) =\u003e {\n    this.updateState({ editorState: event.editorState });\n  });\n  \n  this.sseService.on('tts_started', (event) =\u003e {\n    // Mark narrative entry as playing\n    this.markTTSPlaying(event.eventId, true);\n  });\n  \n  this.sseService.on('tts_complete', (event) =\u003e {\n    this.markTTSPlaying(event.eventId, false);\n  });\n}\n```\n\n## State Updates\n\n```typescript\nprivate updateState(partial: Partial\u003cClientGameState\u003e): void {\n  this.state = { ...this.state, ...partial };\n  this.notifyListeners();\n}\n\nprivate notifyListeners(): void {\n  const state = this.getState();\n  this.listeners.forEach(listener =\u003e {\n    try {\n      listener(state);\n    } catch (error) {\n      console.error('[State] Listener error:', error);\n    }\n  });\n}\n```\n\n## Narrative History Management\n\n```typescript\naddToNarrativeHistory(event: CanonicalEvent): void {\n  const entry: NarrativeEntry = {\n    id: event.id,\n    type: event.eventType,\n    content: event.content,\n    speaker: event.speaker,\n    timestamp: new Date(event.timestamp),\n  };\n  \n  this.updateState({\n    narrativeHistory: [...this.state.narrativeHistory, entry]\n  });\n}\n```\n\n## Singleton Export\n\n```typescript\n// Create singleton with injected services\nexport function createGameStateManager(\n  sseService: SSEService,\n  gameService: GameService\n): GameStateManager;\n\n// For direct import after initialization\nexport let gameStateManager: GameStateManager;\n```","acceptance_criteria":"- [ ] GameStateManager class created\n- [ ] State shape includes all necessary fields\n- [ ] subscribe() notifies listeners on state change\n- [ ] SSE events update state correctly\n- [ ] generation_started sets loading state\n- [ ] generation_complete updates pending content\n- [ ] generation_error sets error state\n- [ ] state_changed updates session\n- [ ] editor_state syncs editor\n- [ ] tts_started/complete updates narrative entries\n- [ ] Actions delegate to GameService and update state\n- [ ] Narrative history maintained\n- [ ] Unit tests for state transitions\n- [ ] Unit tests for SSE event handling","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-10T22:27:32.001502866Z","created_by":"stiwi","updated_at":"2026-01-10T22:27:32.001502866Z","labels":["client","phase-2","state"],"dependencies":[{"issue_id":"reckoning-7el","depends_on_id":"reckoning-dtf","type":"blocks","created_at":"2026-01-10T22:27:32.002659831Z","created_by":"unknown"},{"issue_id":"reckoning-7el","depends_on_id":"reckoning-fdi","type":"blocks","created_at":"2026-01-10T22:27:32.003749865Z","created_by":"unknown"}]}
{"id":"reckoning-8jy","title":"A1: Shared Game Types","description":"Create @reckoning/shared/src/game/ with all Phase 2 types.\n\n## Files to Create\n\n```\npackages/shared/src/game/\n‚îú‚îÄ‚îÄ index.ts          # Re-exports all game types\n‚îú‚îÄ‚îÄ types.ts          # GameState, GameSession, Area, AreaExit, AreaObject, Party, Character, NPC\n‚îú‚îÄ‚îÄ events.ts         # CanonicalEvent, EventType, SSEEvent union type\n‚îú‚îÄ‚îÄ generation.ts     # GeneratedContent, GenerationContext, ContentGenerator interface, ContextBuilder interface  \n‚îú‚îÄ‚îÄ dm.ts             # DMEditorState, DMAction discriminated union, PlaybackMode\n‚îî‚îÄ‚îÄ status.ts         # SystemStatus, GameObservation\n```\n\n## Key Types\n\n### types.ts\n- `GameState`: id, playerId, currentAreaId, turn, timestamps\n- `GameSession`: state + player + currentArea + recentEvents\n- `Area`: id, name, description, exits[], objects[], npcs[], tags[]\n- `AreaExit`: direction, targetAreaId, description, locked?\n- `AreaObject`: id, name, description, interactable, tags[]\n- `Party`: id, gameId, members[]\n- `Character`: id, name, description, class, stats\n- `NPC`: id, name, description, currentAreaId, disposition, tags[]\n\n### events.ts\n- `EventType`: 'narration' | 'party_action' | 'party_dialogue' | 'npc_action' | 'npc_dialogue' | 'environment' | 'dm_injection'\n- `CanonicalEvent`: id, gameId, turn, timestamp, eventType, content, originalGenerated?, speaker?, locationId, witnesses[]\n- `SSEEvent`: Discriminated union for generation_started, generation_complete, generation_error, state_changed, tts_started, tts_complete, editor_state\n\n### generation.ts\n- `GenerationContext`: type, gameState, recentHistory[], historyContext?, dmGuidance?\n- `GeneratedContent`: id, generationType, eventType, content, metadata{speaker?, suggestedActions?}\n- `ContentGenerator`: interface with generate() and regenerate() methods\n- `ContextBuilder`: interface with build() and optional summarizeHistory()\n\n### dm.ts\n- `DMEditorState`: pending, editedContent, status\n- `DMAction`: ACCEPT | EDIT | REGENERATE | INJECT discriminated union\n- `PlaybackMode`: 'auto' | 'paused' | 'stepping' | 'stopped'\n\n### status.ts\n- `SystemStatus`: ai{status, lastGenerationMs?, errorMessage?}, tts{status, queueLength}, db{status, lastSyncAt?}\n- `GameObservation`: turn, totalEvents, eventsThisTurn, currentLocation, partySize, npcsPresent, sessionDuration\n\n## References\n- See docs/plan/phase-2-dm-engine.md for full type definitions\n- Follow existing patterns in packages/shared/src/tts/","acceptance_criteria":"- [ ] All files created in packages/shared/src/game/\n- [ ] All interfaces have JSDoc comments explaining purpose\n- [ ] game/index.ts re-exports all types\n- [ ] packages/shared/src/index.ts exports game types\n- [ ] package.json updated with ./game subpath export\n- [ ] pnpm --filter @reckoning/shared build succeeds\n- [ ] Types importable: import { GameState, CanonicalEvent, SSEEvent } from '@reckoning/shared'\n- [ ] No TypeScript errors in strict mode","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-10T22:23:19.044342964Z","created_by":"stiwi","updated_at":"2026-01-10T22:57:39.95259162Z","closed_at":"2026-01-10T22:57:39.95259162Z","close_reason":"Implemented by polecat nux - all shared game types created","labels":["foundation","phase-2","types"]}
{"id":"reckoning-8ux","title":"D1: Game Engine Core","description":"Create game engine that orchestrates the content generation and game loop.\n\n## Files to Create\n\n```\npackages/server/src/services/game-engine/\n‚îú‚îÄ‚îÄ index.ts              # GameEngine class and exports\n‚îú‚îÄ‚îÄ content-pipeline.ts   # Generate ‚Üí Review ‚Üí Submit pipeline\n‚îú‚îÄ‚îÄ event-loop.ts         # Playback control logic\n‚îî‚îÄ‚îÄ state-manager.ts      # State transition management\n```\n\n## GameEngine (index.ts)\n\n```typescript\nimport { \n  GameState, GeneratedContent, CanonicalEvent, \n  DMAction, PlaybackMode, SSEEvent \n} from '@reckoning/shared';\nimport { BroadcastManager } from '../sse';\nimport { ContentPipeline } from './content-pipeline';\nimport { EventLoop } from './event-loop';\nimport { StateManager } from './state-manager';\n\nclass GameEngine {\n  private pipeline: ContentPipeline;\n  private eventLoop: EventLoop;\n  private stateManager: StateManager;\n  private broadcaster: BroadcastManager;\n  \n  constructor(db: Database, aiProvider: AIProvider, broadcaster: BroadcastManager);\n  \n  // Start a new game\n  async startGame(playerName: string): Promise\u003cGameState\u003e;\n  \n  // Load existing game\n  async loadGame(gameId: string): Promise\u003cGameState\u003e;\n  \n  // Generate next content (triggers AI)\n  async generateNext(gameId: string, options?: {\n    type?: GenerationContext['type'];\n    dmGuidance?: string;\n  }): Promise\u003cvoid\u003e;  // Result delivered via SSE\n  \n  // Submit DM-approved content\n  async submit(gameId: string, action: DMAction): Promise\u003cCanonicalEvent\u003e;\n  \n  // Request regeneration\n  async regenerate(gameId: string, feedback?: string): Promise\u003cvoid\u003e;\n  \n  // Inject DM-authored content\n  async inject(gameId: string, content: string, eventType: EventType): Promise\u003cCanonicalEvent\u003e;\n  \n  // Playback control\n  async setPlaybackMode(gameId: string, mode: PlaybackMode): Promise\u003cvoid\u003e;\n  getPlaybackMode(gameId: string): PlaybackMode;\n  \n  // Get current pending content (if any)\n  getPendingContent(gameId: string): GeneratedContent | null;\n  \n  // Get editor state\n  getEditorState(gameId: string): DMEditorState;\n  \n  // Update editor state (for persistence across refreshes)\n  async updateEditorState(gameId: string, state: Partial\u003cDMEditorState\u003e): Promise\u003cvoid\u003e;\n}\n```\n\n## ContentPipeline (content-pipeline.ts)\n\n```typescript\nclass ContentPipeline {\n  constructor(\n    private contextBuilder: ContextBuilder,\n    private aiProvider: AIProvider,\n    private promptBuilder: typeof buildPrompt\n  );\n  \n  // Generate content and return result\n  async generate(gameId: string, type: GenerationContext['type'], options?: {\n    dmGuidance?: string;\n  }): Promise\u003cResult\u003cGeneratedContent, AIError\u003e\u003e;\n  \n  // Parse AI response into GeneratedContent\n  private parseResponse(response: string): GeneratedContent;\n}\n```\n\n## EventLoop (event-loop.ts)\n\n```typescript\nclass EventLoop {\n  private playbackModes: Map\u003cstring, PlaybackMode\u003e;  // gameId -\u003e mode\n  private pendingGenerations: Map\u003cstring, Promise\u003cvoid\u003e\u003e;  // gameId -\u003e generation promise\n  \n  constructor(private engine: GameEngine);\n  \n  // Set playback mode for a game\n  setMode(gameId: string, mode: PlaybackMode): void;\n  getMode(gameId: string): PlaybackMode;\n  \n  // Called after submit - decides whether to auto-advance\n  async onSubmit(gameId: string): Promise\u003cvoid\u003e;\n  \n  // Manual step (for stepping mode)\n  async step(gameId: string): Promise\u003cvoid\u003e;\n  \n  // Stop current generation\n  async stop(gameId: string): Promise\u003cvoid\u003e;\n}\n```\n\n## StateManager (state-manager.ts)\n\n```typescript\nclass StateManager {\n  constructor(\n    private gameRepo: GameRepository,\n    private eventRepo: EventRepository,\n    private editorRepo: EditorStateRepository,\n    private broadcaster: BroadcastManager\n  );\n  \n  // Create event and update game state\n  async commitEvent(gameId: string, event: Omit\u003cCanonicalEvent, 'id' | 'timestamp'\u003e): Promise\u003cCanonicalEvent\u003e;\n  \n  // Update editor state and broadcast\n  async updateEditorState(gameId: string, state: DMEditorState): Promise\u003cvoid\u003e;\n  \n  // Increment turn\n  async incrementTurn(gameId: string): Promise\u003cnumber\u003e;\n  \n  // Broadcast state change\n  broadcastStateChange(gameId: string, state: GameState): void;\n}\n```\n\n## Flow Example\n\n```\n1. Client calls POST /next\n2. GameEngine.generateNext():\n   a. Broadcast 'generation_started'\n   b. ContentPipeline.generate() calls AI\n   c. Store pending content in EditorState\n   d. Broadcast 'generation_complete'\n   \n3. Client displays content in DM Editor\n\n4. DM clicks Accept\n5. Client calls POST /submit with ACCEPT action\n6. GameEngine.submit():\n   a. Create CanonicalEvent from pending content\n   b. StateManager.commitEvent() saves to DB\n   c. Broadcast 'state_changed'\n   d. Queue TTS playback\n   e. If auto mode, trigger generateNext()\n```\n\n## Notes\n\n- All SSE broadcasts happen through BroadcastManager\n- Pending content stored in EditorStateRepository (survives refresh)\n- Playback mode per-game, not global\n- Error handling broadcasts 'generation_error' event","acceptance_criteria":"- [ ] GameEngine class created with all methods\n- [ ] ContentPipeline generates content via AI provider\n- [ ] AI response parsed into GeneratedContent with eventType\n- [ ] EventLoop manages playback modes (auto/paused/stepping/stopped)\n- [ ] StateManager commits events and broadcasts changes\n- [ ] Pending content stored in EditorStateRepository\n- [ ] SSE events broadcast at each stage\n- [ ] Auto-advance works in auto mode\n- [ ] Step mode generates one then pauses\n- [ ] Unit tests for each component\n- [ ] Integration test for full generate‚Üísubmit flow","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-10T22:26:00.756070407Z","created_by":"stiwi","updated_at":"2026-01-10T22:26:00.756070407Z","labels":["engine","phase-2","server"],"dependencies":[{"issue_id":"reckoning-8ux","depends_on_id":"reckoning-hbj","type":"blocks","created_at":"2026-01-10T22:26:00.757383764Z","created_by":"unknown"},{"issue_id":"reckoning-8ux","depends_on_id":"reckoning-l3e","type":"blocks","created_at":"2026-01-10T22:26:00.75876873Z","created_by":"unknown"}]}
{"id":"reckoning-9ia","title":"D2: Game API Routes","description":"Create Fastify routes for game API endpoints.\n\n## Files to Create\n\n```\npackages/server/src/routes/\n‚îî‚îÄ‚îÄ game.ts    # All game-related routes\n```\n\n## Route Definitions\n\n### POST /api/game/new\nCreate a new game session.\n\n```typescript\n// Request\n{ playerName: string; playerDescription?: string }\n\n// Response\n{ gameId: string; session: GameSession }\n\n// Actions:\n// 1. Create player\n// 2. Create game with starter area\n// 3. Generate initial scene description\n// 4. Return session\n```\n\n### GET /api/game/list\nList saved games.\n\n```typescript\n// Response\n{ saves: SaveSlot[] }\n```\n\n### GET /api/game/:id\nGet current game state.\n\n```typescript\n// Response\n{ session: GameSession; editorState: DMEditorState }\n```\n\n### POST /api/game/:id/save\nSave game to slot.\n\n```typescript\n// Request\n{ name: string }\n\n// Response\n{ slot: SaveSlot }\n```\n\n### POST /api/game/:id/load\nLoad game from slot.\n\n```typescript\n// Request\n{ slotId: string }\n\n// Response\n{ session: GameSession }\n\n// Also broadcasts state_changed via SSE\n```\n\n### GET /api/game/:id/events (SSE)\nSubscribe to real-time events.\n\n```typescript\n// Response: text/event-stream\n// Events: generation_started, generation_complete, generation_error,\n//         state_changed, tts_started, tts_complete, editor_state, heartbeat\n```\n\n### GET /api/game/:id/pending\nGet pending generated content.\n\n```typescript\n// Response\n{ pending: GeneratedContent | null; editorState: DMEditorState }\n```\n\n### PUT /api/game/:id/editor\nUpdate editor state.\n\n```typescript\n// Request\n{ editedContent?: string; status?: DMEditorState['status'] }\n\n// Response\n{ editorState: DMEditorState }\n\n// Also broadcasts editor_state via SSE\n```\n\n### POST /api/game/:id/submit\nSubmit DM-approved content.\n\n```typescript\n// Request\n{ action: DMAction }\n// DMAction = { type: 'ACCEPT' } \n//          | { type: 'EDIT', content: string }\n\n// Response\n{ event: CanonicalEvent; session: GameSession }\n\n// Also broadcasts state_changed via SSE\n```\n\n### POST /api/game/:id/regenerate\nRequest AI regeneration.\n\n```typescript\n// Request\n{ feedback?: string }\n\n// Response\n{ status: 'generating' }\n\n// Result delivered via SSE generation_complete\n```\n\n### POST /api/game/:id/inject\nInject DM-authored content.\n\n```typescript\n// Request\n{ content: string; eventType: EventType; speaker?: string }\n\n// Response\n{ event: CanonicalEvent; session: GameSession }\n```\n\n### POST /api/game/:id/next\nTrigger next content generation.\n\n```typescript\n// Request\n{ type?: GenerationContext['type']; dmGuidance?: string }\n\n// Response\n{ status: 'generating' }\n\n// Result delivered via SSE generation_complete\n```\n\n### POST /api/game/:id/control\nSet playback mode.\n\n```typescript\n// Request\n{ mode: PlaybackMode }  // 'auto' | 'paused' | 'stepping' | 'stopped'\n\n// Response\n{ mode: PlaybackMode }\n```\n\n### GET /api/game/:id/status\nGet system status and game stats.\n\n```typescript\n// Response\n{ \n  system: SystemStatus;\n  observation: GameObservation;\n}\n```\n\n## Request Validation Schemas\n\nUse Fastify JSON Schema validation for all routes:\n\n```typescript\nconst newGameSchema = {\n  body: {\n    type: 'object',\n    required: ['playerName'],\n    properties: {\n      playerName: { type: 'string', minLength: 1, maxLength: 50 },\n      playerDescription: { type: 'string', maxLength: 500 },\n    },\n  },\n};\n```\n\n## Error Responses\n\n```typescript\n// Standard error format\n{\n  error: {\n    code: string;      // e.g., 'GAME_NOT_FOUND', 'INVALID_REQUEST'\n    message: string;\n    retryable?: boolean;\n  }\n}\n\n// HTTP status codes:\n// 400 - Invalid request\n// 404 - Game/resource not found\n// 500 - Internal error\n// 503 - AI unavailable\n```\n\n## SSE Endpoint Implementation\n\n```typescript\nfastify.get('/:id/events', async (request, reply) =\u003e {\n  const { id } = request.params;\n  \n  // Verify game exists\n  const game = gameRepo.findById(id);\n  if (\\!game) return reply.status(404).send({ error: { code: 'GAME_NOT_FOUND' } });\n  \n  // Set up SSE\n  setupSSEResponse(reply);\n  \n  // Subscribe to broadcasts\n  const clientId = broadcastManager.subscribe(id, reply.raw);\n  \n  // Send initial state\n  broadcastManager.send(clientId, {\n    type: 'state_changed',\n    state: game\n  });\n  \n  // Handle disconnect\n  request.raw.on('close', () =\u003e {\n    broadcastManager.unsubscribe(id, clientId);\n  });\n  \n  // Don't end the response - keep it open for SSE\n  return reply;\n});\n```","acceptance_criteria":"- [ ] All 14 routes implemented\n- [ ] POST /new creates game and returns session\n- [ ] GET /list returns saved games\n- [ ] GET /:id returns current session\n- [ ] POST /:id/save saves game state\n- [ ] POST /:id/load restores game state\n- [ ] GET /:id/events streams SSE correctly\n- [ ] GET /:id/pending returns pending content\n- [ ] PUT /:id/editor updates and broadcasts editor state\n- [ ] POST /:id/submit creates event and broadcasts\n- [ ] POST /:id/regenerate triggers AI and returns via SSE\n- [ ] POST /:id/inject creates DM event\n- [ ] POST /:id/next triggers generation\n- [ ] POST /:id/control sets playback mode\n- [ ] GET /:id/status returns system status\n- [ ] Request validation with JSON schemas\n- [ ] Error responses follow standard format\n- [ ] Integration tests for each route\n- [ ] SSE endpoint tested with curl","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-10T22:26:27.190919798Z","created_by":"stiwi","updated_at":"2026-01-10T22:26:27.190919798Z","labels":["api","phase-2","routes","server"],"dependencies":[{"issue_id":"reckoning-9ia","depends_on_id":"reckoning-8ux","type":"blocks","created_at":"2026-01-10T22:26:27.192511839Z","created_by":"unknown"},{"issue_id":"reckoning-9ia","depends_on_id":"reckoning-9vu","type":"blocks","created_at":"2026-01-10T22:26:27.193692534Z","created_by":"unknown"}]}
{"id":"reckoning-9vu","title":"B3: SSE Broadcast Service","description":"Create Server-Sent Events broadcast service for real-time client updates.\n\n## Files to Create\n\n```\npackages/server/src/services/sse/\n‚îú‚îÄ‚îÄ index.ts              # Exports\n‚îú‚îÄ‚îÄ broadcast-manager.ts  # Connection and broadcast management\n‚îî‚îÄ‚îÄ types.ts              # Internal types\n```\n\n## BroadcastManager\n\n```typescript\ninterface SSEClient {\n  id: string;\n  gameId: string;\n  response: FastifyReply;\n  connectedAt: Date;\n}\n\nclass BroadcastManager {\n  private clients: Map\u003cstring, Set\u003cSSEClient\u003e\u003e;  // gameId -\u003e clients\n  private heartbeatInterval: NodeJS.Timeout;\n  \n  constructor();\n  \n  // Subscribe a client to game events\n  subscribe(gameId: string, response: FastifyReply): string;  // Returns clientId\n  \n  // Unsubscribe a client\n  unsubscribe(gameId: string, clientId: string): void;\n  \n  // Broadcast event to all clients of a game\n  broadcast(gameId: string, event: SSEEvent): void;\n  \n  // Send event to specific client\n  send(clientId: string, event: SSEEvent): void;\n  \n  // Get connected client count for a game\n  getClientCount(gameId: string): number;\n  \n  // Start heartbeat timer (call on server start)\n  startHeartbeat(intervalMs?: number): void;\n  \n  // Stop heartbeat timer (call on server shutdown)\n  stopHeartbeat(): void;\n  \n  // Cleanup all connections for a game\n  cleanup(gameId: string): void;\n}\n\n// Singleton export\nexport const broadcastManager: BroadcastManager;\n```\n\n## SSE Event Format\n\nEvents sent as:\n```\nevent: \u003cevent_type\u003e\ndata: \u003cjson_payload\u003e\n\n```\n\nExample:\n```\nevent: generation_complete\ndata: {\"id\":\"abc\",\"content\":\"Marcus steps forward...\",\"eventType\":\"party_action\"}\n\n```\n\n## SSEEvent Types (from shared)\n\n```typescript\ntype SSEEvent =\n  | { type: 'generation_started'; contentType: string }\n  | { type: 'generation_complete'; content: GeneratedContent }\n  | { type: 'generation_error'; error: string }\n  | { type: 'state_changed'; state: GameState }\n  | { type: 'tts_started'; eventId: string }\n  | { type: 'tts_complete'; eventId: string }\n  | { type: 'editor_state'; editorState: DMEditorState }\n  | { type: 'heartbeat'; timestamp: string };\n```\n\n## Fastify Route Helper\n\n```typescript\n// Helper to set up SSE response headers\nfunction setupSSEResponse(reply: FastifyReply): void {\n  reply.raw.setHeader('Content-Type', 'text/event-stream');\n  reply.raw.setHeader('Cache-Control', 'no-cache');\n  reply.raw.setHeader('Connection', 'keep-alive');\n  reply.raw.setHeader('X-Accel-Buffering', 'no');  // Disable nginx buffering\n}\n\n// Helper to format SSE message\nfunction formatSSEMessage(event: SSEEvent): string {\n  return `event: ${event.type}\\ndata: ${JSON.stringify(event)}\\n\\n`;\n}\n```\n\n## Heartbeat\n\n- Send heartbeat every 30 seconds to keep connections alive\n- Detect dead connections and clean up\n- Format: `event: heartbeat\\ndata: {\"timestamp\":\"...\"}`\n\n## Connection Cleanup\n\n- On client disconnect (response close event)\n- On game end\n- On server shutdown","acceptance_criteria":"- [ ] BroadcastManager class created with all methods\n- [ ] subscribe() returns clientId and sets up SSE headers\n- [ ] broadcast() sends to all connected clients for a game\n- [ ] unsubscribe() removes client and cleans up\n- [ ] Heartbeat sends every 30 seconds\n- [ ] Dead connections detected and cleaned up\n- [ ] SSE format correct (event + data lines)\n- [ ] Unit tests for BroadcastManager\n- [ ] Manual test: connect via curl, receive heartbeats\n- [ ] Memory leak check: clients properly removed on disconnect","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T22:24:19.649778045Z","created_by":"stiwi","updated_at":"2026-01-10T23:06:55.298066574Z","closed_at":"2026-01-10T23:06:55.298066574Z","close_reason":"Implemented by polecat rictus - SSE broadcast service added","labels":["phase-2","realtime","server","sse"],"dependencies":[{"issue_id":"reckoning-9vu","depends_on_id":"reckoning-8jy","type":"blocks","created_at":"2026-01-10T22:24:19.65121581Z","created_by":"unknown"}]}
{"id":"reckoning-abi","title":"E7: Client Main Integration","description":"Wire up all client components in main.ts.\n\nUpdate packages/client/src/main.ts to:\n- Initialize services (SSEService, GameService, TTSService)\n- Create and mount all UI components\n- Wire up event handlers between components\n- Handle game lifecycle (new game, load, save)\n- Establish SSE connection on game start\n\nThis is the client-side integration point that brings all components together.","acceptance_criteria":"- [ ] App initializes all services correctly\n- [ ] All UI components render in proper layout\n- [ ] SSE connection established on game start\n- [ ] User can start new game from UI\n- [ ] Event handlers properly connected between components","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-10T22:29:39.256115423Z","created_by":"stiwi","updated_at":"2026-01-10T22:29:39.256115423Z","labels":["client","integration","phase-2"],"dependencies":[{"issue_id":"reckoning-abi","depends_on_id":"reckoning-1zj","type":"blocks","created_at":"2026-01-10T22:29:39.257364283Z","created_by":"unknown"},{"issue_id":"reckoning-abi","depends_on_id":"reckoning-e3s","type":"blocks","created_at":"2026-01-10T22:29:39.258523858Z","created_by":"unknown"},{"issue_id":"reckoning-abi","depends_on_id":"reckoning-q5k","type":"blocks","created_at":"2026-01-10T22:29:39.259970211Z","created_by":"unknown"}]}
{"id":"reckoning-b8m","title":"F3: Polish \u0026 Testing","description":"Final polish and test coverage for Phase 2.\n\nPolish work:\n- User-friendly error messages\n- Loading indicators for async operations\n- Edge case handling (network errors, AI failures)\n- Graceful degradation when services unavailable\n\nTesting:\n- Unit test coverage for new services\n- Integration tests for game routes\n- Manual testing checklist completion","acceptance_criteria":"- [ ] Error messages are user-friendly\n- [ ] Loading states shown during async operations\n- [ ] Edge cases handled gracefully\n- [ ] Unit tests pass with reasonable coverage\n- [ ] Integration tests pass\n- [ ] Manual test checklist completed","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-10T22:30:00.473133898Z","created_by":"stiwi","updated_at":"2026-01-10T22:30:00.473133898Z","labels":["phase-2","polish","testing"],"dependencies":[{"issue_id":"reckoning-b8m","depends_on_id":"reckoning-42l","type":"blocks","created_at":"2026-01-10T22:30:00.474171973Z","created_by":"unknown"},{"issue_id":"reckoning-b8m","depends_on_id":"reckoning-0yo","type":"blocks","created_at":"2026-01-10T22:30:00.475374643Z","created_by":"unknown"}]}
{"id":"reckoning-dtf","title":"E1: Client SSE Service","description":"Create client-side SSE service for receiving real-time server updates.\n\n## Files to Create\n\n```\npackages/client/src/services/sse/\n‚îú‚îÄ‚îÄ index.ts    # SSEService class\n‚îî‚îÄ‚îÄ types.ts    # Client-side event handler types\n```\n\n## SSEService\n\n```typescript\nimport { SSEEvent } from '@reckoning/shared';\n\ntype SSEEventHandler\u003cT extends SSEEvent['type']\u003e = (\n  event: Extract\u003cSSEEvent, { type: T }\u003e\n) =\u003e void;\n\ninterface SSEServiceConfig {\n  reconnectDelay?: number;      // Default: 1000ms\n  maxReconnectDelay?: number;   // Default: 30000ms\n  reconnectBackoff?: number;    // Default: 1.5\n}\n\nclass SSEService {\n  private eventSource: EventSource | null = null;\n  private handlers: Map\u003cstring, Set\u003cFunction\u003e\u003e = new Map();\n  private reconnectAttempts: number = 0;\n  private config: Required\u003cSSEServiceConfig\u003e;\n  private gameId: string | null = null;\n  \n  constructor(config?: SSEServiceConfig);\n  \n  // Connect to game SSE stream\n  connect(gameId: string): void;\n  \n  // Disconnect and cleanup\n  disconnect(): void;\n  \n  // Check connection status\n  isConnected(): boolean;\n  \n  // Get current game ID\n  getGameId(): string | null;\n  \n  // Register event handler\n  on\u003cT extends SSEEvent['type']\u003e(\n    eventType: T, \n    handler: SSEEventHandler\u003cT\u003e\n  ): () =\u003e void;  // Returns unsubscribe function\n  \n  // Remove event handler\n  off\u003cT extends SSEEvent['type']\u003e(\n    eventType: T, \n    handler: SSEEventHandler\u003cT\u003e\n  ): void;\n  \n  // Remove all handlers for an event type\n  offAll(eventType?: SSEEvent['type']): void;\n}\n```\n\n## Implementation Details\n\n### Connection\n\n```typescript\nconnect(gameId: string): void {\n  if (this.eventSource) {\n    this.disconnect();\n  }\n  \n  this.gameId = gameId;\n  this.eventSource = new EventSource(`/api/game/${gameId}/events`);\n  \n  this.eventSource.onopen = () =\u003e {\n    console.log('[SSE] Connected');\n    this.reconnectAttempts = 0;\n  };\n  \n  this.eventSource.onerror = (error) =\u003e {\n    console.error('[SSE] Error:', error);\n    this.handleReconnect();\n  };\n  \n  // Register handlers for each event type\n  const eventTypes: SSEEvent['type'][] = [\n    'generation_started', 'generation_complete', 'generation_error',\n    'state_changed', 'tts_started', 'tts_complete', \n    'editor_state', 'heartbeat'\n  ];\n  \n  eventTypes.forEach(type =\u003e {\n    this.eventSource\\!.addEventListener(type, (e: MessageEvent) =\u003e {\n      const data = JSON.parse(e.data);\n      this.emit(type, data);\n    });\n  });\n}\n```\n\n### Reconnection with Backoff\n\n```typescript\nprivate handleReconnect(): void {\n  if (\\!this.gameId) return;\n  \n  const delay = Math.min(\n    this.config.reconnectDelay * Math.pow(this.config.reconnectBackoff, this.reconnectAttempts),\n    this.config.maxReconnectDelay\n  );\n  \n  this.reconnectAttempts++;\n  console.log(`[SSE] Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts})`);\n  \n  setTimeout(() =\u003e {\n    if (this.gameId) {\n      this.connect(this.gameId);\n    }\n  }, delay);\n}\n```\n\n### Event Emission\n\n```typescript\nprivate emit(type: string, data: SSEEvent): void {\n  const handlers = this.handlers.get(type);\n  if (handlers) {\n    handlers.forEach(handler =\u003e {\n      try {\n        handler(data);\n      } catch (error) {\n        console.error(`[SSE] Handler error for ${type}:`, error);\n      }\n    });\n  }\n}\n```\n\n## Usage Example\n\n```typescript\nconst sse = new SSEService();\n\n// Connect to game\nsse.connect('game-123');\n\n// Listen for generation complete\nconst unsubscribe = sse.on('generation_complete', (event) =\u003e {\n  console.log('Generated:', event.content);\n  updateEditor(event.content);\n});\n\n// Later: cleanup\nunsubscribe();\nsse.disconnect();\n```\n\n## Connection States\n\nTrack and expose connection state:\n- 'connecting' - EventSource created, waiting for open\n- 'connected' - onopen fired, receiving events\n- 'reconnecting' - Connection lost, attempting reconnect\n- 'disconnected' - Manually disconnected or gave up","acceptance_criteria":"- [ ] SSEService class created with all methods\n- [ ] connect() creates EventSource to /api/game/:id/events\n- [ ] disconnect() closes EventSource and cleans up\n- [ ] on() registers typed event handlers\n- [ ] off() removes specific handler\n- [ ] Auto-reconnect with exponential backoff\n- [ ] Connection state tracking\n- [ ] Event handlers receive typed SSEEvent payloads\n- [ ] Handlers wrapped in try-catch to prevent crashes\n- [ ] Unit tests for handler registration/removal\n- [ ] Manual test: connect, receive events, reconnect on disconnect","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T22:26:49.205965511Z","created_by":"stiwi","updated_at":"2026-01-10T23:06:55.202182733Z","closed_at":"2026-01-10T23:06:55.202182733Z","close_reason":"Implemented by polecat capable - client SSE service added","labels":["client","phase-2","realtime","sse"],"dependencies":[{"issue_id":"reckoning-dtf","depends_on_id":"reckoning-8jy","type":"blocks","created_at":"2026-01-10T22:26:49.207265521Z","created_by":"unknown"}]}
{"id":"reckoning-e3s","title":"E5: UI Components - Panels","description":"Create info panel components for party, area, status bar, and game stats.\n\nFiles to create in packages/client/src/components/:\n- party-panel.ts - Party member list with names, classes, status\n- area-panel.ts - Current location, exits, objects, NPCs\n- status-bar.ts - System status (AI, TTS, DB indicators)\n- game-stats.ts - Turn count, event count, session duration\n\nAll panels subscribe to GameStateManager for updates.","acceptance_criteria":"- [ ] Party panel shows party members with names and classes\n- [ ] Area panel shows location name, exits, objects, NPCs\n- [ ] Status bar shows AI/TTS/DB status indicators\n- [ ] Game stats shows turn count, event count, duration\n- [ ] All panels update reactively via state subscription","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-10T22:30:18.848784179Z","created_by":"stiwi","updated_at":"2026-01-10T22:30:18.848784179Z","labels":["client","phase-2","ui"],"dependencies":[{"issue_id":"reckoning-e3s","depends_on_id":"reckoning-7el","type":"blocks","created_at":"2026-01-10T22:30:18.849888854Z","created_by":"unknown"}]}
{"id":"reckoning-fdi","title":"E2: Client Game Service","description":"Create client-side game API service for server communication.\n\n## Files to Create\n\n```\npackages/client/src/services/game/\n‚îú‚îÄ‚îÄ index.ts    # GameService class\n‚îî‚îÄ‚îÄ types.ts    # Request/response types (if needed beyond shared)\n```\n\n## GameService\n\n```typescript\nimport {\n  GameSession, GameState, GeneratedContent, CanonicalEvent,\n  DMAction, PlaybackMode, DMEditorState, SystemStatus, \n  GameObservation, SaveSlot, EventType\n} from '@reckoning/shared';\n\nclass GameService {\n  private baseUrl: string;\n  private currentGameId: string | null = null;\n  \n  constructor(baseUrl?: string);\n  \n  // Get current game ID\n  getGameId(): string | null;\n  \n  // Create new game\n  async newGame(playerName: string, description?: string): Promise\u003cGameSession\u003e;\n  \n  // Get game session\n  async getSession(gameId: string): Promise\u003c{ session: GameSession; editorState: DMEditorState }\u003e;\n  \n  // List saved games\n  async listSaves(): Promise\u003cSaveSlot[]\u003e;\n  \n  // Save game\n  async saveGame(gameId: string, name: string): Promise\u003cSaveSlot\u003e;\n  \n  // Load game\n  async loadGame(gameId: string, slotId: string): Promise\u003cGameSession\u003e;\n  \n  // Get pending content\n  async getPending(gameId: string): Promise\u003c{ pending: GeneratedContent | null; editorState: DMEditorState }\u003e;\n  \n  // Update editor state\n  async updateEditor(gameId: string, state: Partial\u003cDMEditorState\u003e): Promise\u003cDMEditorState\u003e;\n  \n  // Submit DM action\n  async submit(gameId: string, action: DMAction): Promise\u003c{ event: CanonicalEvent; session: GameSession }\u003e;\n  \n  // Request regeneration\n  async regenerate(gameId: string, feedback?: string): Promise\u003cvoid\u003e;\n  \n  // Inject DM content\n  async inject(gameId: string, content: string, eventType: EventType, speaker?: string): Promise\u003c{ event: CanonicalEvent; session: GameSession }\u003e;\n  \n  // Trigger next generation\n  async next(gameId: string, options?: { type?: string; dmGuidance?: string }): Promise\u003cvoid\u003e;\n  \n  // Set playback mode\n  async setPlaybackMode(gameId: string, mode: PlaybackMode): Promise\u003cPlaybackMode\u003e;\n  \n  // Get status\n  async getStatus(gameId: string): Promise\u003c{ system: SystemStatus; observation: GameObservation }\u003e;\n}\n```\n\n## Implementation Pattern\n\n```typescript\nprivate async request\u003cT\u003e(\n  method: 'GET' | 'POST' | 'PUT' | 'DELETE',\n  path: string,\n  body?: object\n): Promise\u003cT\u003e {\n  const url = `${this.baseUrl}${path}`;\n  const options: RequestInit = {\n    method,\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  };\n  \n  if (body) {\n    options.body = JSON.stringify(body);\n  }\n  \n  const response = await fetch(url, options);\n  \n  if (\\!response.ok) {\n    const error = await response.json();\n    throw new GameServiceError(\n      error.error?.code || 'UNKNOWN_ERROR',\n      error.error?.message || 'Request failed',\n      response.status\n    );\n  }\n  \n  return response.json();\n}\n```\n\n## Error Handling\n\n```typescript\nclass GameServiceError extends Error {\n  constructor(\n    public code: string,\n    message: string,\n    public statusCode: number\n  ) {\n    super(message);\n    this.name = 'GameServiceError';\n  }\n}\n```\n\n## Usage Example\n\n```typescript\nconst gameService = new GameService();\n\n// Start new game\nconst session = await gameService.newGame('Player One', 'A brave adventurer');\nconst gameId = session.state.id;\n\n// Submit edited content\nconst result = await gameService.submit(gameId, {\n  type: 'EDIT',\n  content: 'Marcus draws his sword and steps forward cautiously.'\n});\n\n// Trigger next generation\nawait gameService.next(gameId, { dmGuidance: 'Have the NPC react suspiciously' });\n```\n\n## Singleton Export\n\n```typescript\n// Export singleton instance for app-wide use\nexport const gameService = new GameService();\n\n// Also export class for testing\nexport { GameService, GameServiceError };\n```","acceptance_criteria":"- [ ] GameService class created with all methods\n- [ ] newGame() creates game and returns session\n- [ ] getSession() fetches current state\n- [ ] listSaves() returns saved games\n- [ ] saveGame() saves to slot\n- [ ] loadGame() restores from slot\n- [ ] getPending() returns pending content\n- [ ] updateEditor() updates editor state\n- [ ] submit() submits DM action\n- [ ] regenerate() requests regeneration\n- [ ] inject() creates DM event\n- [ ] next() triggers generation\n- [ ] setPlaybackMode() changes playback\n- [ ] getStatus() returns system status\n- [ ] GameServiceError class for error handling\n- [ ] Singleton instance exported\n- [ ] Unit tests with fetch mocking","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-10T22:27:07.565446733Z","created_by":"stiwi","updated_at":"2026-01-10T22:27:07.565446733Z","labels":["api","client","phase-2"],"dependencies":[{"issue_id":"reckoning-fdi","depends_on_id":"reckoning-8jy","type":"blocks","created_at":"2026-01-10T22:27:07.56673555Z","created_by":"unknown"},{"issue_id":"reckoning-fdi","depends_on_id":"reckoning-dtf","type":"blocks","created_at":"2026-01-10T22:27:07.567931535Z","created_by":"unknown"}]}
{"id":"reckoning-hbj","title":"B2: Database Repositories","description":"Create repository classes for database access with clean interfaces.\n\n## Files to Create\n\n```\npackages/server/src/db/repositories/\n‚îú‚îÄ‚îÄ index.ts              # Re-exports all repositories\n‚îú‚îÄ‚îÄ game-repository.ts    # Game CRUD operations\n‚îú‚îÄ‚îÄ event-repository.ts   # Event history operations\n‚îú‚îÄ‚îÄ area-repository.ts    # Area queries\n‚îú‚îÄ‚îÄ party-repository.ts   # Party member operations\n‚îî‚îÄ‚îÄ save-repository.ts    # Save/load slot operations\n```\n\n## GameRepository\n\n```typescript\nclass GameRepository {\n  constructor(db: Database);\n  \n  create(playerId: string, startAreaId: string): GameState;\n  findById(id: string): GameState | null;\n  update(game: Partial\u003cGameState\u003e \u0026 { id: string }): void;\n  delete(id: string): void;\n  setPlaybackMode(id: string, mode: PlaybackMode): void;\n  incrementTurn(id: string): number;\n  getSession(id: string): GameSession | null;  // Full session with related data\n}\n```\n\n## EventRepository\n\n```typescript\nclass EventRepository {\n  constructor(db: Database);\n  \n  create(event: Omit\u003cCanonicalEvent, 'id' | 'timestamp'\u003e): CanonicalEvent;\n  findById(id: string): CanonicalEvent | null;\n  findByGame(gameId: string, options?: { limit?: number; offset?: number }): CanonicalEvent[];\n  findByTurn(gameId: string, turn: number): CanonicalEvent[];\n  getRecentContext(gameId: string, limit?: number): CanonicalEvent[];\n  countByGame(gameId: string): number;\n  countByTurn(gameId: string, turn: number): number;\n}\n```\n\n## AreaRepository\n\n```typescript\nclass AreaRepository {\n  constructor(db: Database);\n  \n  findById(id: string): Area | null;\n  findAll(): Area[];\n  getWithDetails(id: string): Area \u0026 { exits: AreaExit[]; objects: AreaObject[]; npcs: NPC[] } | null;\n  getNPCsInArea(areaId: string): NPC[];\n  moveNPC(npcId: string, toAreaId: string): void;\n}\n```\n\n## PartyRepository\n\n```typescript\nclass PartyRepository {\n  constructor(db: Database);\n  \n  create(gameId: string, members: Omit\u003cCharacter, 'id'\u003e[]): Character[];\n  findByGame(gameId: string): Character[];\n  findById(id: string): Character | null;\n  update(member: Partial\u003cCharacter\u003e \u0026 { id: string }): void;\n}\n```\n\n## SaveRepository\n\n```typescript\ninterface SaveSlot {\n  id: string;\n  gameId: string;\n  name: string;\n  turn: number;\n  sessionDurationMs: number;\n  createdAt: string;\n}\n\nclass SaveRepository {\n  constructor(db: Database);\n  \n  save(gameId: string, name: string, snapshot: object): SaveSlot;\n  load(saveId: string): { slot: SaveSlot; snapshot: object } | null;\n  list(gameId?: string): SaveSlot[];\n  delete(saveId: string): void;\n  findByName(name: string): SaveSlot | null;\n}\n```\n\n## EditorStateRepository\n\n```typescript\nclass EditorStateRepository {\n  constructor(db: Database);\n  \n  get(gameId: string): DMEditorState | null;\n  set(gameId: string, state: DMEditorState): void;\n  clear(gameId: string): void;\n}\n```\n\n## Notes\n- All repositories take Database instance in constructor\n- Use prepared statements for performance\n- Return domain types from @reckoning/shared\n- Handle JSON serialization for array/object columns","acceptance_criteria":"- [ ] All repository files created\n- [ ] GameRepository: create, findById, update, delete, getSession work\n- [ ] EventRepository: create, findByGame, getRecentContext work\n- [ ] AreaRepository: findById, getWithDetails, getNPCsInArea work\n- [ ] PartyRepository: create, findByGame, update work\n- [ ] SaveRepository: save, load, list, delete work\n- [ ] EditorStateRepository: get, set, clear work\n- [ ] Unit tests for each repository (mock database)\n- [ ] Integration test with real SQLite database\n- [ ] All methods return proper TypeScript types","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-10T22:24:50.791019146Z","created_by":"stiwi","updated_at":"2026-01-10T22:24:50.791019146Z","labels":["database","phase-2","server"],"dependencies":[{"issue_id":"reckoning-hbj","depends_on_id":"reckoning-hrd","type":"blocks","created_at":"2026-01-10T22:24:50.792177282Z","created_by":"unknown"}]}
{"id":"reckoning-hrd","title":"B1: SQLite Schema \u0026 Connection","description":"Create SQLite database layer with schema and connection management.\n\n## Files to Create\n\n```\npackages/server/src/db/\n‚îú‚îÄ‚îÄ index.ts          # Database connection, getDatabase(), runMigrations()\n‚îú‚îÄ‚îÄ schema.sql        # Table definitions\n‚îî‚îÄ‚îÄ seed.ts           # Seed starter area data\n```\n\n## Schema Tables\n\n### games\n```sql\nCREATE TABLE games (\n  id TEXT PRIMARY KEY,\n  player_id TEXT NOT NULL,\n  current_area_id TEXT NOT NULL,\n  turn INTEGER DEFAULT 0,\n  playback_mode TEXT DEFAULT 'auto',\n  created_at TEXT DEFAULT (datetime('now')),\n  updated_at TEXT DEFAULT (datetime('now'))\n);\n```\n\n### players\n```sql\nCREATE TABLE players (\n  id TEXT PRIMARY KEY,\n  game_id TEXT NOT NULL REFERENCES games(id),\n  name TEXT NOT NULL,\n  description TEXT,\n  created_at TEXT DEFAULT (datetime('now'))\n);\n```\n\n### party_members\n```sql\nCREATE TABLE party_members (\n  id TEXT PRIMARY KEY,\n  game_id TEXT NOT NULL REFERENCES games(id),\n  name TEXT NOT NULL,\n  description TEXT,\n  class TEXT,\n  created_at TEXT DEFAULT (datetime('now'))\n);\n```\n\n### areas\n```sql\nCREATE TABLE areas (\n  id TEXT PRIMARY KEY,\n  name TEXT NOT NULL,\n  description TEXT NOT NULL,\n  tags TEXT,  -- JSON array\n  created_at TEXT DEFAULT (datetime('now'))\n);\n```\n\n### area_exits\n```sql\nCREATE TABLE area_exits (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  area_id TEXT NOT NULL REFERENCES areas(id),\n  direction TEXT NOT NULL,\n  target_area_id TEXT NOT NULL,\n  description TEXT,\n  locked INTEGER DEFAULT 0\n);\n```\n\n### area_objects\n```sql\nCREATE TABLE area_objects (\n  id TEXT PRIMARY KEY,\n  area_id TEXT NOT NULL REFERENCES areas(id),\n  name TEXT NOT NULL,\n  description TEXT,\n  interactable INTEGER DEFAULT 1,\n  tags TEXT  -- JSON array\n);\n```\n\n### npcs\n```sql\nCREATE TABLE npcs (\n  id TEXT PRIMARY KEY,\n  name TEXT NOT NULL,\n  description TEXT,\n  current_area_id TEXT REFERENCES areas(id),\n  disposition TEXT DEFAULT 'neutral',\n  tags TEXT,  -- JSON array\n  created_at TEXT DEFAULT (datetime('now'))\n);\n```\n\n### events\n```sql\nCREATE TABLE events (\n  id TEXT PRIMARY KEY,\n  game_id TEXT NOT NULL REFERENCES games(id),\n  turn INTEGER NOT NULL,\n  timestamp TEXT DEFAULT (datetime('now')),\n  event_type TEXT NOT NULL,\n  content TEXT NOT NULL,\n  original_generated TEXT,\n  speaker TEXT,\n  location_id TEXT NOT NULL,\n  witnesses TEXT  -- JSON array\n);\nCREATE INDEX idx_events_game ON events(game_id);\nCREATE INDEX idx_events_turn ON events(game_id, turn);\n```\n\n### saves\n```sql\nCREATE TABLE saves (\n  id TEXT PRIMARY KEY,\n  game_id TEXT NOT NULL REFERENCES games(id),\n  name TEXT NOT NULL,\n  turn INTEGER NOT NULL,\n  session_duration_ms INTEGER,\n  snapshot TEXT NOT NULL,  -- JSON blob of full state\n  created_at TEXT DEFAULT (datetime('now'))\n);\n```\n\n### editor_state\n```sql\nCREATE TABLE editor_state (\n  game_id TEXT PRIMARY KEY REFERENCES games(id),\n  pending_content TEXT,  -- JSON GeneratedContent\n  edited_content TEXT,\n  status TEXT DEFAULT 'empty',\n  updated_at TEXT DEFAULT (datetime('now'))\n);\n```\n\n## Connection Management\n\n- Use better-sqlite3 for synchronous SQLite\n- WAL mode for better concurrency\n- Lazy initialization via getDatabase()\n- Auto-run migrations on first connect\n\n## Seed Data\n\nStarter tavern area (The Wayward Rest):\n- 1 area: tavern_common\n- 3 exits: north (stairs), east (bar), south (street)\n- 2 objects: hearth, notice_board\n- 1 NPC: Maren (bartender)\n\n## Dependencies\n- Add better-sqlite3 and @types/better-sqlite3 to server package","acceptance_criteria":"- [ ] packages/server/src/db/index.ts exports getDatabase()\n- [ ] schema.sql contains all table definitions\n- [ ] WAL mode enabled for SQLite\n- [ ] Migrations run automatically on first connection\n- [ ] Seed data creates starter tavern area\n- [ ] better-sqlite3 added to dependencies\n- [ ] Database file created at ./data/reckoning.db (or from env)\n- [ ] pnpm --filter @reckoning/server build succeeds\n- [ ] Can manually verify: sqlite3 ./data/reckoning.db '.tables' shows all tables","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-10T22:23:39.305617803Z","created_by":"stiwi","updated_at":"2026-01-10T22:23:39.305617803Z","labels":["database","phase-2","server"],"dependencies":[{"issue_id":"reckoning-hrd","depends_on_id":"reckoning-8jy","type":"blocks","created_at":"2026-01-10T22:23:39.334357162Z","created_by":"unknown"}]}
{"id":"reckoning-l3e","title":"C3: Context Builder","description":"Create context builder that assembles GenerationContext from game state.\n\n## Files to Create\n\n```\npackages/server/src/services/ai/\n‚îî‚îÄ‚îÄ context-builder.ts    # ContextBuilder class\n```\n\n## ContextBuilder Interface (from shared)\n\n```typescript\ninterface ContextBuilder {\n  build(gameId: string, type: GenerationContext['type']): Promise\u003cGenerationContext\u003e;\n  // Extension point for future summarization\n  summarizeHistory?(events: CanonicalEvent[]): string;\n}\n```\n\n## Implementation\n\n```typescript\nimport { \n  GenerationContext, \n  GameState, \n  Area, \n  CanonicalEvent,\n  Character,\n  NPC \n} from '@reckoning/shared';\nimport { GameRepository, EventRepository, AreaRepository, PartyRepository } from '../../db/repositories';\n\nclass DefaultContextBuilder implements ContextBuilder {\n  constructor(\n    private gameRepo: GameRepository,\n    private eventRepo: EventRepository,\n    private areaRepo: AreaRepository,\n    private partyRepo: PartyRepository\n  );\n  \n  async build(\n    gameId: string, \n    type: GenerationContext['type'],\n    options?: {\n      dmGuidance?: string;\n      targetNpcId?: string;  // For npc_response\n      triggeringEventId?: string;  // For npc_response\n    }\n  ): Promise\u003cGenerationContext\u003e {\n    // 1. Fetch game state\n    const game = this.gameRepo.findById(gameId);\n    if (!game) throw new Error('Game not found');\n    \n    // 2. Fetch current area with details\n    const area = this.areaRepo.getWithDetails(game.currentAreaId);\n    if (!area) throw new Error('Area not found');\n    \n    // 3. Fetch party members\n    const party = this.partyRepo.findByGame(gameId);\n    \n    // 4. Fetch recent history (full for now, extension point for summarization)\n    const recentHistory = this.eventRepo.getRecentContext(gameId);\n    \n    // 5. Build context based on type\n    return {\n      type,\n      gameState: game,\n      currentArea: area,\n      party,\n      npcsPresent: area.npcs,\n      recentHistory,\n      historyContext: this.summarizeHistory?.(recentHistory),\n      dmGuidance: options?.dmGuidance,\n    };\n  }\n  \n  // Extension point - returns undefined by default (use full history)\n  // Override this method to implement summarization strategies\n  summarizeHistory?(events: CanonicalEvent[]): string {\n    // Default: no summarization\n    return undefined;\n  }\n}\n\n// Factory function for creating with injected dependencies\nexport function createContextBuilder(db: Database): ContextBuilder {\n  return new DefaultContextBuilder(\n    new GameRepository(db),\n    new EventRepository(db),\n    new AreaRepository(db),\n    new PartyRepository(db)\n  );\n}\n```\n\n## Extended GenerationContext\n\nThe GenerationContext returned includes additional resolved data:\n\n```typescript\ninterface ExtendedGenerationContext extends GenerationContext {\n  currentArea: Area \u0026 { exits: AreaExit[]; objects: AreaObject[] };\n  party: Character[];\n  npcsPresent: NPC[];\n}\n```\n\n## Summarization Extension Point\n\nFor Phase 3+ when context windows become a concern:\n\n```typescript\nclass SummarizingContextBuilder extends DefaultContextBuilder {\n  private aiProvider: AIProvider;\n  \n  async summarizeHistory(events: CanonicalEvent[]): string {\n    if (events.length \u003c 50) return undefined;  // Use full history\n    \n    // Summarize older events, keep recent ones verbatim\n    const recentCount = 10;\n    const recent = events.slice(-recentCount);\n    const older = events.slice(0, -recentCount);\n    \n    const summary = await this.aiProvider.execute({\n      prompt: `Summarize these RPG events concisely: ${JSON.stringify(older)}`\n    });\n    \n    return `Previous events summary: ${summary.content}\\n\\nRecent events: ${formatEvents(recent)}`;\n  }\n}\n```\n\n## Notes\n\n- Full history used for now (Phase 2)\n- Extension point ready for summarization (Phase 3+)\n- Repositories injected for testability\n- All data fetched in single build() call for efficiency","acceptance_criteria":"- [ ] DefaultContextBuilder class created\n- [ ] build() fetches game state from GameRepository\n- [ ] build() fetches area with details from AreaRepository\n- [ ] build() fetches party members from PartyRepository\n- [ ] build() fetches recent history from EventRepository\n- [ ] Returns complete GenerationContext with all resolved data\n- [ ] summarizeHistory extension point defined (returns undefined by default)\n- [ ] createContextBuilder factory function exported\n- [ ] Unit tests with mocked repositories\n- [ ] Integration test with real database\n- [ ] Handles missing game/area gracefully with errors","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-10T22:25:32.69164593Z","created_by":"stiwi","updated_at":"2026-01-10T22:25:32.69164593Z","labels":["ai","phase-2","server"],"dependencies":[{"issue_id":"reckoning-l3e","depends_on_id":"reckoning-3bw","type":"blocks","created_at":"2026-01-10T22:25:32.693078669Z","created_by":"unknown"},{"issue_id":"reckoning-l3e","depends_on_id":"reckoning-hbj","type":"blocks","created_at":"2026-01-10T22:25:32.694223372Z","created_by":"unknown"}]}
{"id":"reckoning-q5k","title":"E6: UI Components - Save/Load","description":"Create save/load modal component for game persistence.\n\nFile to create: packages/client/src/components/save-load-modal.ts\n\nFeatures:\n- Save modal with name input field\n- Load modal showing list of saved games\n- New Game option to start fresh\n- Delete save option with confirmation\n- Integration with GameService save/load methods","acceptance_criteria":"- [ ] Save modal accepts save name input\n- [ ] Load modal displays list of saved games\n- [ ] New Game option available\n- [ ] Delete save option with confirmation dialog\n- [ ] Modal integrates with GameService API methods","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-10T22:29:32.014987613Z","created_by":"stiwi","updated_at":"2026-01-10T22:29:32.014987613Z","labels":["client","phase-2","ui"],"dependencies":[{"issue_id":"reckoning-q5k","depends_on_id":"reckoning-fdi","type":"blocks","created_at":"2026-01-10T22:29:32.016184863Z","created_by":"unknown"}]}
